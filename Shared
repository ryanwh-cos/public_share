/*TMCI18N BEGIN HEADER*/
#if !defined( tmBundle_EXISTS )
#define TM_ON_STARTUP tmInitGlobS_swpwait                                      
#include "tmcilib.h"
static struct TMBundle tmBundle = {"swpwait.pc",NULL,NULL,NULL,NULL};
#define tmBundle_EXISTS
#endif
/*TMCI18N END HEADER*/

/* AUDIT_TRAIL_C_I18N
-- PROJECT : MSGKEY
-- MODULE  : SWPWAIT
-- SOURCE  : enUS
-- TARGET  : I18N
-- DATE    : Thu Apr 08 21:45:10 2010
-- MSGSIGN : #0000000000000000
END AUDIT_TRAIL_C_I18N */
/* ******************************************************* */
/*  Program:               SWPWAIT.PC                      */
/*  Author:                Evans                           */
/*  Date Written:          30 JUL 2003                     */
/*  Description:           Process Waitlisted students.    */
/*                                                         */
/*  This program will move students from the waitlist to   */
/*     registered status if a seat is available.           */
/*                                                         */
/*  Seats may become available by:                         */ 
/*     1. Student drops                                    */
/*     2. Instructor drops no shows                        */
/*     3. Instructor adds extra seats using                */
/*        Faculty Web.                                     */
/*     4. Department opens a new section                   */
/*        meeting the same days and times.                 */
/*        (This functionality is disabled)                 */
/*                                                         */
/*  The waitlist may be controlled by:                     */
/*     1. Instructor drops no shows                        */
/*     2. SWPWAIT removes unqualified students             */
/*     3. SWPCLRW clears and closes waitlist after the     */
/*           10% date                                      */
/*                                                         */
/*  This process will run daily for terms with active      */
/*     registration.                                       */
/*  1. It is launched by CRON.                             */
/*  2. Instuctors have the option of freezing the roll     */
/*        using Faculty Web.                               */
/*                                                         */
/*  The following checks will be made before the student   */
/*  is registered:                                         */
/*    1.  Student is not deceased.                         */
/*    2.  Student does not have registration holds.        */
/*    3.  Student status permits registration.             */
/*    4.  Student enrollment status permits registration.  */
/*    5.  Meets the prerequisite.                          */
/*    6.  Does not exceed the repeat count/hours.          */
/*    7.  Does not have a time conflict.                   */
/*    8.  Does not exceed student max hours.               */
/*    9.  Is not a duplicate course.                       */
/*                                                         */
/*   If any of the checks fail then the student is         */
/*     removed from the wait list.                         */
/*                                                         */
/*   NOTE: The Financial Aid office must run               */
/*         SFRTMST before running the National             */
/*         Student Clearinghouse process (SWRNSLC)         */
/*                                                         */
/*         Fees are assessed by SFRFASC.  Run from CRON.   */
/*                                                         */
/*  Date Last Change:  09-MAY-2005                         */
/*                                                         */
/* ******************************************************* */
/*  Parameters:                                            */ 
/*  01        Campus        required   Single              */
/*  02        Term          required   Single              */
/*  03        Email (Y/N)   required   Single              */
/*                                                         */ 
/*  Tables Used:           SFRSTCR                         */
/*                         SFRMEET                         */
/*                         SSBSECT                         */
/*                         SFBETRM                         */
/*                         SSBXLST                         */
/*                         SSRXLST                         */
/*                         SFRBTCH                         */
/*                         SWBWLST                         */
/*                         SWRWLLG                         */
/*                         GOREMAL                         */
/*                         SFRSRPO                         */
/*  Audit Trail:                                           */
/*      20-APR-2004 Commented out printf's in Alternate    */
/*                  CRN search routines.                   */
/*      23-APR-2004 Fixed alternate crn cursor,            */
/*                  ssbsect_cursor, to bypass              */
/*                  sections student has dropped.          */
/*      26-APR-2004 Fixed alternate crn cursor,            */
/*                  ssbsect_cursor, to bypass              */
/*                  sections having an active waitlist.    */
/*      14-MAY-2004 Initialize Hold flag to 'N'.           */
/*                  Initialize  Status flag to 'N'.        */
/*                  Initialize deceased flag to 'N'.       */
/*      03-JUN-2004 Banner 6.0 implementation.             */
/*                  1. Replace repeat check function       */
/*                     (fw_repeat_check) with new Banner 6 */
/*                     repeat procedure (shkrpts.p_count   */
/*                     _repeat_units).                     */
/*                  2. Use schedule credit hrs if hold     */
/*                     credit hours is null. (Caused by    */
/*                     waitlisting a student directly.)    */
/*      28-AUG-2004 Do not write a row to the TBRCBRQ      */
/*                  table.  SFRFASC writes one too and     */
/*                  duplicate rows are created.            */
/*      09-MAY-2005 Disable the alternate crn              */
/*                  functionality.                         */
/* ******************************************************* */

#define FP_COUNT 20

EXEC SQL INCLUDE kccd_lib.pc;

EXEC SQL BEGIN DECLARE SECTION;

/* ****************************** */
/*  Parameter variables           */
/* ****************************** */
static TMCHAR ask_term[7]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR ask_email_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;

/* ****************************** */
/*  Application variables         */
/* ****************************** */
static int class_eligible;
static int class_not_started;
static int roll_active;
static int seats_available;
static int use_xtra_seats;
static int use_alternate_crn;
static TMCHAR eligible_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;       /* Used in check preq call */
static TMCHAR deceased_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR class_not_started_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR hold_flag[21]={0}/*TMCI18N CHANGED FROM ""*/;    /* COS  */
static TMCHAR stdt_status_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR enrl_status_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR repeat_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static int   repeat_count=0;
static int   repeat_count_limit=0;
static float repeat_units=0;
static float repeat_units_limit=0;
static TMCHAR message_out[31]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR duplicate_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR max_units_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR time_conflict_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;  
static TMCHAR ssrxlst_flag[2]={0}/*TMCI18N CHANGED FROM ""*/;
static int update_failed;
static int bad_open;
static TMCHAR reason_code[2]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR reason_code_desc[21]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR action_code[2]={0}/*TMCI18N CHANGED FROM ""*/;

/* ****************************** */
/*  Data variables                */
/* ****************************** */
static TMCHAR stdt_pidm[9];
static TMCHAR crn[7];
static TMCHAR alternate_crn[7];
static TMCHAR footprint_crn[7];
static TMCHAR wl_date[17];
static TMCHAR levl_code[3];
static TMCHAR subj_code[5];
static TMCHAR campus_code[4];
static TMCHAR crse_numb[6];
static TMCHAR schd_code_section[4];
static TMCHAR crse_title[31];
static TMCHAR ptrm_code[4];
static TMCHAR ptrm_start_date[12];
static TMCHAR ptrm_end_date[12];
static int ssbsect_seats;
static int seats_count;
static int xtra_seats_used;
static TMCHAR census_enrl_date[9];
static TMCHAR sun_day[2];
static TMCHAR mon_day[2];
static TMCHAR tue_day[2];
static TMCHAR wed_day[2];
static TMCHAR thu_day[2];
static TMCHAR fri_day[2];
static TMCHAR sat_day[2];
static TMCHAR begin_time[5];
static TMCHAR end_time[5];
static TMCHAR schd_code[4];
static TMCHAR bldg_code_t[7];
static TMCHAR bldg_code[7];
static TMCHAR room_code_t[11];
static TMCHAR room_code[11];
static float credit_hours;
static int   wait_capacity;
static float total_credit_hours;
static TMCHAR xlst_group[3];
static int xlst_avail;
static TMCHAR ssbsect_rowid[255]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR alt_ssbsect_rowid[255]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR ssbxlst_rowid[255]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR swbwlst_rowid[255]={0}/*TMCI18N CHANGED FROM ""*/;
static TMCHAR stdt_email[91];
static TMCHAR stdt_name[61];
static float  max_hrs;
static TMCHAR  ests_code[3];
static TMCHAR compare_date[9];

/* ****************************** */
/*   Indicator variables          */
/* ****************************** */
short Ind_01;
short Ind_02;
short Ind_03;
short Ind_04;
short Ind_05;
short Ind_06;
short Ind_07;
short Ind_08;
short Ind_09;
short Ind_10;
short Ind_11;
short Ind_12;
short Ind_13;
short Ind_20;
short Ind_21;
short Ind_22;
short Ind_30;
short Ind_31;
short Ind_32;
short Ind_33;
short Ind_34;
short Ind_35;
short Ind_36;
short Ind_37;
short Ind_38;
short Ind_39;
short Ind_40;
short Ind_41;

EXEC SQL END DECLARE SECTION;

UFILE *eb;

/* ********************************** */
/*    General work areas              */
/* ********************************** */
static TMCHAR prev_crn[7];
static TMCHAR reason_desc[150];
static TMCHAR email_string[6000];
static TMCHAR campus_email[25];
static TMCHAR campus_contact[25];
/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR test_email[25]=_TMC("brians@cos.edu");*/
static TMCHAR TMCHARRAY_GLOB_DCL(test_email,25,_TMC("leem@cos.edu"));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR COS_mailfrom[25]=_TMC("admissions@cos.edu");*/ 
static TMCHAR TMCHARRAY_GLOB_DCL(COS_mailfrom,25,_TMC("admissions@cos.edu"));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR COS_contact[25]=_TMC("(559) 737-6140");*/
static TMCHAR TMCHARRAY_GLOB_DCL(COS_contact,25,_TMC("(559) 737-6140"));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_X[150]=_TMC("student is deceased.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_X,150,_TMC("student is deceased."));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_H[150]=_TMC("you have an active registration hold.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_H,150,_TMC("you have an active registration hold."));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_P[150]=_TMC("you no longer meet the prerequisites.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_P,150,_TMC("you no longer meet the prerequisites."));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_S[150]=_TMC("your status indicates you are not eligible to register. ");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_S,150,_TMC("your status indicates you are not eligible to register. "));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_E[150]=_TMC("your enrollment status indicates you are not eligible to register. ");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_E,150,_TMC("your enrollment status indicates you are not eligible to register. "));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_D[150]=_TMC("you are currently registered in a duplicate section.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_D,150,_TMC("you are currently registered in a duplicate section."));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_R[150]=_TMC("this course will cause you to exceed the maximum repeats allowed.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_R,150,_TMC("this course will cause you to exceed the maximum repeats allowed."));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_U[150]=_TMC("this course will cause you to exceed the maximum units allowed.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_U,150,_TMC("this course will cause you to exceed the maximum units allowed."));

/*TMCI18N CHANGED DECLARATION*/ /*static TMCHAR reason_T[150]=_TMC("this course has a time conflict with a course for which you are currently registered.");*/
static TMCHAR TMCHARRAY_GLOB_DCL(reason_T,150,_TMC("this course has a time conflict with a course for which you are currently registered."));


/* ********************************* */
/*   Function prototypes             */
/* ********************************* */
static int ask_for_prams(void);
static int process_report(void);
static int retrieve_prams(void);
static int report_define (void);
static int top_page (void);

/* ********************************************** */
/*   Local Function Prototypes                    */
/* ********************************************** */
static int sfrstcr_cursor (int mode);
static void process_sfrstcr (void);
static void process_sfrstcr_first (void);
static int ssbsect_cursor (int mode);
static void process_ssbsect (void);
static int ssrmeet_cursor (int mode);
static void process_ssrmeet (void);
static void process_ssrmeet_first (void);
static void process_ssrmeet_last (void);
static void create_template (void);
static void process_ssrmeet_day(TMCHAR*);
static void check_roll (void);
static void check_roll_active (void);
static void check_seats (void);
static void find_alternate_crn(void);
static void process_roll (void);
static void process_drop (void);
static int check_preq (void);
static int check_start_date (void);
static int check_deceased (void);
static int check_hold (void);
static int check_status_stdt (void);
static int check_status_enrl (void);
static int check_repeat (void);
static int check_duplicate (void);
static int check_time_conflict (void);
static int check_max_units (void);
static int selemail (void);
static void build_email_body (void);
static int send_email (void);
static int vrfy_term (void);
static int vrfy_email_flag (void);
static int initialize_used_flags(void);
static int initialize_footprint (void);
static void format_compare_date (void);

struct time_footprint  /* An array of this structure defines   */
                       /* a day/time footprint for a section.  */
{
  TMCHAR  schd[4];
  TMCHAR  day[2];
  TMCHAR  begin[5];
  TMCHAR  end[5];
} toe;

int xt;                              /* size of template */
int xf;                              /* size of footprint*/
int used_flag[FP_COUNT];             /* compare flag */
struct time_footprint tp[FP_COUNT];  /* footprint template */
struct time_footprint fp[FP_COUNT];  /* alternate footprint */

int main(int argc, TMCHAR *argv[])
{
  extern short sqltrace_flag;

  rptopen(user_pass,argc,argv);

  login();
 
  if (sqltrace_flag) 
    EXEC SQL 
      ALTER SESSION SET SQL_TRACE TRUE;

  initialize(_TMC("SWPWAIT"), _TMC("5.5"),_TMC("Waitlist Roll Process"));
 
  format_compare_date();

  if (Banner) 
    {
      retrieve_prams();
      oracle_commit();
    }
  else
    ask_for_prams();
  
  if (parameters_ok)
    process_report();

  exit2os(EXIT_SUCCESS);
  return(EXIT_SUCCESS);
}

/* ********************************************* */
/*   Process data                                */
/*                                               */
/*     This is the main processing function      */
/*     modification is required.                 */
/* ********************************************* */
static int process_report (void)
{       
  tmstrcpy(campus_contact,COS_contact);
  tmstrcpy(campus_email,COS_mailfrom);

  report(sfrstcr_cursor, process_sfrstcr,process_sfrstcr_first,NULL);
  return(TRUE);
}

/* *************************************************** */
/*   Request job parameters from console               */
/*                                                     */
/*      Insert calls to ask_s_val / ask_m_val          */
/*        as required                                  */
/* *************************************************** */
static int ask_for_prams (void)
{
  parameters_ok=ask_s_val(_TMC("Term Code: "),ask_term,6,ALPHA,_TMC("01"),vrfy_term);
  if(parameters_ok)
    parameters_ok=ask_s_val(_TMC("Send Emails? (Y/N): "),ask_email_flag,1,ALPHA,_TMC("02"),vrfy_email_flag);
  if(parameters_ok)
    linelimit=ask_lines();
  return(TRUE);
}

/* **************************************************** */
/*   Retrieve Job submission parameters                 */
/*                                                      */
/*      Insert calls to read_s_val / read_m_val         */
/*         as required                                  */
/* **************************************************** */
static int retrieve_prams (void)
{
  read_s_val(ask_term,_TMC("01"));
  read_s_val(ask_email_flag,_TMC("02"));
  linelimit=read_lines();
  del_parms();
  return(TRUE);
}

/* ************************************************ */
/*    Validate term                                 */
/* ************************************************ */
static int vrfy_term (void)
{
  validate_ok=FALSE;
  
  EXEC SQL
    SELECT 1
      INTO :validate_ok
      FROM DUAL
     WHERE EXISTS
            (SELECT 'x'
                FROM STVTERM
               WHERE STVTERM_CODE = :ask_term);
     
  POSTORA;
  
  if(NO_ROWS_FOUND)
    validate_ok=FALSE;
    
  return(validate_ok);
}

/* ************************************************ */
/*    Validate email_flag                           */
/* ************************************************ */
static int vrfy_email_flag ()
{
  validate_ok=FALSE;
  
  if(tmstrcmp(ask_email_flag,_TMC("Y"))==0 || tmstrcmp(ask_email_flag,_TMC("N"))==0)
    validate_ok=TRUE;
    
  return(validate_ok);
}

/* ************************************************** */
/*  Cursor to select all students who are waitlisted. */
/*  for the selected term.                            */
/*  Ordered by CRN and date/time waitlisted.          */
/*  Note do not order by seq number (renumbered daily)*/
/* ************************************************** */
static int sfrstcr_cursor (int mode) 
{
  EXEC SQL
    DECLARE cursor_001 CURSOR for
     SELECT sfrstcr_pidm,
            sfrstcr_crn,
            TO_CHAR(sfrstcr_rsts_date,'YYYYMMDDHH24:MI:SS') waitlist_date,
            NVL(sfrstcr_credit_hr_hold,
                   NVL(ssbsect_credit_hrs,scbcrse_credit_hr_low)),
            sfrstcr_levl_code,
            ssbsect_subj_code,
            ssbsect_crse_numb,
            ssbsect_schd_code,
            NVL(ssbsect_crse_title,scbcrse_title),
            ssbsect_ptrm_code,
            TO_CHAR(ssbsect_ptrm_start_date,G$_DATE.GET_NLS_DATE_FORMAT),
            TO_CHAR(ssbsect_ptrm_end_date,G$_DATE.GET_NLS_DATE_FORMAT),
            TO_CHAR(ssbsect_census_enrl_date,'YYYYMMDD'),
            ssbsect_camp_code
       FROM scbcrse,
            ssbsect,
            sfrstcr
      WHERE scbcrse_subj_code = ssbsect_subj_code
        AND scbcrse_crse_numb = ssbsect_crse_numb
        AND scbcrse_eff_term =
            (SELECT MAX(b.scbcrse_eff_term)
             FROM scbcrse b
             WHERE b.scbcrse_subj_code = ssbsect_subj_code
              AND b.scbcrse_crse_numb = ssbsect_crse_numb
              AND b.scbcrse_eff_term <= :ask_term)
        AND ssbsect_crn = sfrstcr_crn
        AND ssbsect_term_code = sfrstcr_term_code
        AND sfrstcr_rsts_code = 'WL'
        AND sfrstcr_term_code = :ask_term
        AND (sfrstcr_error_flag IS NULL
             OR   sfrstcr_error_flag NOT IN ('D', 'F'))
      ORDER  BY 2,3;
       
  if (mode == CLOSE_CURSOR)
    {
      EXEC SQL
        CLOSE cursor_001;
      POSTORA;
      return(TRUE);
    }
    
  if(mode == FIRST_ROW)
    { 
      EXEC SQL
        OPEN cursor_001;
      POSTORA;
    }
    
  EXEC SQL 
    FETCH cursor_001 INTO
      :stdt_pidm:Ind_01,
      :crn:Ind_02,
      :wl_date:Ind_03,
      :credit_hours:Ind_04,
      :levl_code:Ind_05,
      :subj_code:Ind_06,
      :crse_numb:Ind_07,
      :schd_code_section:Ind_08,
      :crse_title:Ind_09,
      :ptrm_code:Ind_10,
      :ptrm_start_date:Ind_11,
      :ptrm_end_date:Ind_12,
      :census_enrl_date:Ind_13,
      :campus_code;
  POSTORA;
  
  if(NO_ROWS_FOUND)
    return(FALSE);
  else
    fix_null(census_enrl_date,Ind_13); 

  return(TRUE);
} 


/* ****************************************************** */
/*   Clear previous CRN.                                  */
/* ****************************************************** */
static void process_sfrstcr_first (void)
{   
  tmstrcpy(prev_crn,_TMC(""));
  process_sfrstcr();
}   

/* ****************************************************** */
/*   Process SFRSTCR data                                 */
/* ****************************************************** */
static void process_sfrstcr (void)
{   
/* leem - COS */
  tmprintf(&tmBundle, _TMC("Process CRN {0} \n"), crn);
/* Build day/time template needed in alternate crn search*/
  if (tmstrcmp(crn,prev_crn)!=0)  
   {
   tmstrcpy(footprint_crn,crn);
   report(ssrmeet_cursor,process_ssrmeet,process_ssrmeet_first,create_template);
   tmstrcpy(prev_crn,crn);
   }
   
  if(check_start_date())
   {
    check_roll();

    if(!class_eligible)
     {
      process_drop();
     }
    else
     {
      check_roll_active();
      tmprintf(&tmBundle, _TMC("Roll Active: {0,number,integer} {1} {2}\n"), roll_active, stdt_pidm, crn);
      if(roll_active)
       {
        check_seats();
        if(seats_available)
         {
            tmprintf(&tmBundle, _TMC("Process Roll {0} {1}\n"),stdt_pidm, crn);
            process_roll();
         }
       }
     }
   }
}

/* ****************************************************** */
/*   Check SWBWLST to determine if roll is active.        */
/*   NOTE:  Roll will be inactivated by the instructor    */
/*          via the web (waitlist roll ind = 'N').        */
/* ****************************************************** */
static void check_roll_active (void)
{
  EXEC SQL
    SELECT 0
      INTO :roll_active
      FROM swbwlst
     WHERE swbwlst_crn = :crn
       AND swbwlst_term_code = :ask_term
       AND swbwlst_waitlist_roll_ind = 'N';
  POSTORA;

  if(NO_ROWS_FOUND)
    roll_active = 1;
}

/* *********************************************************** */
/*   Check SSBSECT,SWBWLST,alternate crns for seats available. */
/* *********************************************************** */
static void check_seats (void)
{
  seats_available = FALSE;
  use_xtra_seats = FALSE;
  use_alternate_crn = FALSE;

/* Get extra seat count used.  This is needed to use up course seats  */
/* after more drops have occured and extra seats have been used       */
    EXEC SQL
      SELECT NVL(swbwlst_xtra_seats_taken,0)
        INTO :xtra_seats_used
        FROM swbwlst
       WHERE swbwlst_crn = :crn
         AND swbwlst_term_code = :ask_term;
    POSTORA;

    if (NO_ROWS_FOUND) 
    {
      xtra_seats_used = 0;              
    }

/* Get section record and lock it.                                    */
/* Note: If max seats have been zeroed by SWRZERO use projected seats.*/
  EXEC SQL
  SELECT rowid,
         DECODE(ssbsect_max_enrl,0,ssbsect_proj_enrl + :xtra_seats_used - ssbsect_enrl,
         ssbsect_max_enrl + :xtra_seats_used  - ssbsect_enrl)
    INTO :ssbsect_rowid,
         :ssbsect_seats
    FROM ssbsect
   WHERE ssbsect_crn = :crn
     AND ssbsect_term_code = :ask_term
   FOR UPDATE OF ssbsect_enrl, ssbsect_seats_avail;
  POSTORA;

  if (NO_ROWS_FOUND) 
  {
   tmprintf(&tmBundle, _TMC("SYSTEM ERROR IN CHECK SEATS {0}\n"),crn);
   return;
  }

  if (ssbsect_seats > 0)
  {
/* Make sure cross list seats avail if cross listed */
   EXEC SQL 
   SELECT ssrxlst_xlst_group, ssbxlst_seats_avail, ssbxlst.rowid
     INTO :xlst_group, :xlst_avail, :ssbxlst_rowid
     FROM ssbxlst, ssrxlst
    WHERE ssbxlst_term_code = ssrxlst_term_code
      AND ssbxlst_xlst_group = ssrxlst_xlst_group
      AND ssrxlst_crn = :crn
      AND ssrxlst_term_code = :ask_term;
   POSTORA;
             
   if(NO_ROWS_FOUND)
      *xlst_group=NULL_STRING;

   if ((*xlst_group && xlst_avail > 0) || !*xlst_group) 
      {
       seats_available = TRUE;
       tmprintf(&tmBundle, _TMC("Seats avail {0,number,integer} {1}\n"),seats_available,crn);
       return;
      }
   }

/* Check if instructor requested additional seats. */
    EXEC SQL
      SELECT rowid
        INTO :swbwlst_rowid
        FROM swbwlst
       WHERE swbwlst_xtra_seats_remain > 0
         AND swbwlst_crn = :crn
         AND swbwlst_term_code = :ask_term;
    POSTORA;

    if (ROWS_FOUND) 
    {
      use_xtra_seats = TRUE;                    
      seats_available = TRUE;                   
      tmprintf(&tmBundle, _TMC("Extra seats avail {0,number,integer} {1}\n"),use_xtra_seats,crn);
      return;
    }

/* Check if an alternate section is available. */
/*  
  find_alternate_crn();
  if (use_alternate_crn)
  {
    printf("Alternate crn found %d %s\n",use_alternate_crn, alternate_crn);
    seats_available = TRUE;             
    return;
  }
*/

/* No seats available, clear record lock */
    oracle_rollback();
}      

/* **************************************************************** */
/*   Process alternate crn candidates.                              */
/*   If one is found the USE_ALTERNATE_CRN flag will be set to TRUE.*/ 
/*   The alternate crn will be moved to CRN.                        */                                                               
/* **************************************************************** */
static void find_alternate_crn(void)
{          
/* try to find an open alternate course meeting at the same time */
   report(ssbsect_cursor,process_ssbsect,NULL,NULL);
}       

/* ************************************************** */
/*  Cursor to select all CRNS that may be eligible    */
/*  as an alternate for a closed section.             */
/*  Must have the same Subject, Course,               */
/*                     Start and End dates            */
/*                     Part of Term code              */
/*  Must have open seats.                             */
/*  Must be active.                                   */
/*  Must not require instructor signature.            */
/*  Student must not be waitlisted in CRN.            */
/* ************************************************** */
static int ssbsect_cursor (int mode)
{ 
  EXEC SQL
    DECLARE cursor_002 CURSOR for
      SELECT ssbsect_crn,
             DECODE(ssbsect_max_enrl,0,ssbsect_proj_enrl - ssbsect_enrl,
                    ssbsect_max_enrl - ssbsect_enrl)
        FROM ssbsect, stvssts
       WHERE ssbsect_subj_code = :subj_code
         AND ssbsect_crse_numb = :crse_numb
         AND ssbsect_ptrm_code = :ptrm_code
         AND TRUNC(ssbsect_ptrm_start_date) = :ptrm_start_date
         AND TRUNC(ssbsect_ptrm_end_date) = :ptrm_end_date
         AND (ssbsect_max_enrl - ssbsect_enrl > 0
              OR ssbsect_proj_enrl - ssbsect_enrl > 0)
         AND ssbsect_wait_count <= 0 
         AND ssbsect_sapr_code IS NULL
         AND ssbsect_ssts_code = stvssts_code
         AND stvssts_reg_ind = 'Y'
         AND NOT EXISTS
             (SELECT 'Y' FROM sfrstcr
              WHERE sfrstcr_crn = ssbsect_crn
                AND sfrstcr_term_code = ssbsect_term_code
                AND sfrstcr_pidm = :stdt_pidm)
         AND ssbsect_term_code = :ask_term
         AND ssbsect_crn <> :crn
      ORDER  BY 2;
       
  if (mode == CLOSE_CURSOR)
    {
      EXEC SQL
        CLOSE cursor_002;
      POSTORA;
      return(TRUE);
    }
    
  if(mode == FIRST_ROW)
    {
      EXEC SQL
        OPEN cursor_002;
      POSTORA;
    }
    
  EXEC SQL 
    FETCH cursor_002 INTO
      :footprint_crn:Ind_20,
      :seats_count:Ind_21;

  POSTORA;
  
  if(NO_ROWS_FOUND)
    return(FALSE);
    
  return(TRUE);
} 

/* **************************************************************** */
/*   Process alternate crn candidates.                              */
/*   1. Create their time footprint                                 */  
/*   2. Match it to the closed sections footprint.                  */  
/* **************************************************************** */
static void process_ssbsect(void)
{
/* bypass section is a matching footprint as already been found */
   if (use_alternate_crn)
     return;

/* bypass cross listed courses */
   EXEC SQL
     SELECT 'Y' 
       INTO ssrxlst_flag
       FROM ssrxlst
      WHERE ssrxlst_term_code = :ask_term
        AND ssrxlst_crn = :footprint_crn;
   POSTORA;
   if (ROWS_FOUND)
      return;    
   
   report(ssrmeet_cursor,process_ssrmeet,process_ssrmeet_first,process_ssrmeet_last);   
}

/* ************************************************** */
/*  Cursor to select meeting times for alternate      */
/*  open section search.                              */
/*                                                    */
/* ************************************************** */
static int ssrmeet_cursor (int mode)
{ 
  EXEC SQL
    DECLARE cursor_003 CURSOR for
     SELECT  NVL(ssrmeet_sun_day,'/0'), 
             NVL(ssrmeet_mon_day,'/0'),
             NVL(ssrmeet_tue_day,'/0'), 
             NVL(ssrmeet_wed_day,'/0'), 
             NVL(ssrmeet_thu_day,'/0'),
             NVL(ssrmeet_fri_day,'/0'),
             NVL(ssrmeet_sat_day,'/0'),
             NVL(ssrmeet_begin_time,'/0'),
             NVL(ssrmeet_end_time,'/0'),
             NVL(ssrmeet_schd_code,'/0'),
             NVL(ssrmeet_bldg_code,'TBA'),
             NVL(ssrmeet_room_code,'TBA')
           FROM ssrmeet
          WHERE ssrmeet_term_code = :ask_term
            AND ssrmeet_crn = :footprint_crn;
  POSTORA;
    
  if (mode == CLOSE_CURSOR)
    {
      EXEC SQL
        CLOSE cursor_003;
      POSTORA;
      return(TRUE);
    }   
  
  if(mode == FIRST_ROW)
    {
      EXEC SQL
        OPEN cursor_003;
      POSTORA;
    }

  EXEC SQL 
    FETCH cursor_003 INTO
      :sun_day:Ind_30,
      :mon_day:Ind_31,
      :tue_day:Ind_32,
      :wed_day:Ind_33,
      :thu_day:Ind_34,
      :fri_day:Ind_35,
      :sat_day:Ind_36,
      :begin_time:Ind_37,
      :end_time:Ind_38,
      :schd_code:Ind_39,
      :bldg_code_t:Ind_40,
      :room_code_t:Ind_41;
  POSTORA;
  
  if(NO_ROWS_FOUND)
    return(FALSE);
  else
  
     fix_null(sun_day,Ind_30); 
     fix_null(mon_day,Ind_31); 
     fix_null(tue_day,Ind_32); 
     fix_null(wed_day,Ind_33); 
     fix_null(thu_day,Ind_34); 
     fix_null(fri_day,Ind_35); 
     fix_null(sat_day,Ind_36); 
     fix_null(schd_code,Ind_39);    
     fix_null(bldg_code_t,Ind_40);    
     fix_null(room_code_t,Ind_41);
      
  return(TRUE);
}

/* **************************************************************** */
/*   Process alternate crn candidates.                              */
/*   1. Create their time footprint                                 */
/*   2. Match it to the closed sections footprint.                  */ 
/* **************************************************************** */
static void process_ssrmeet_first(void)
{
 tmstrcpy(bldg_code, _TMC("TBA"));
 tmstrcpy(room_code, _TMC("TBA"));
 
 initialize_footprint();
 initialize_used_flags();
 xf=0;

 process_ssrmeet();     
}

/* **************************************************************** */
/*   Process alternate crn candidates.                              */
/*   1. Create their time footprint and match to template.          */ 
/* **************************************************************** */
static void process_ssrmeet(void)
{
  int x=xf;
 
  if (tmstrcmp(bldg_code_t,_TMC(""))!=0)
   tmstrcpy(bldg_code, bldg_code_t);
   
  if (tmstrcmp(room_code_t,_TMC(""))!=0)
   tmstrcpy(room_code, room_code_t);
        
  if(tmstrcmp(sun_day,_TMC("U"))==0)
    process_ssrmeet_day(sun_day);

  if(tmstrcmp(mon_day,_TMC("M"))==0)  
   process_ssrmeet_day(mon_day);

  if(tmstrcmp(tue_day,_TMC("T"))==0)
    process_ssrmeet_day(tue_day);

  if(tmstrcmp(wed_day,_TMC("W"))==0)  
   process_ssrmeet_day(wed_day);

  if(tmstrcmp(thu_day,_TMC("R"))==0)
    process_ssrmeet_day(thu_day);

  if(tmstrcmp(fri_day,_TMC("F"))==0)  
    process_ssrmeet_day(fri_day);

  if(tmstrcmp(sat_day,_TMC("S"))==0)  
    process_ssrmeet_day(sat_day);

/* no days found in ssrmeet */
  if(xf==x)
   {
    if (xf+1>FP_COUNT)
    { 
      tmprintf(&tmBundle, _TMC("Template Max exceeded for:{0}\0"),footprint_crn);
      return;
    }
    tmstrcpy(fp[xf].day, _TMC("\0"));
    tmstrcpy(fp[xf].begin, begin_time);
    tmstrcpy(fp[xf].end, end_time);
    tmstrcpy(fp[xf].schd, schd_code);
    xf++;

   }    
}

/* **************************************************************** */
/*   Add day "toe" to Footprint.                                    */ 
/* **************************************************************** */
static void process_ssrmeet_day(TMCHAR* day)
{
 if (xf+1>FP_COUNT)
 { 
  tmprintf(&tmBundle, _TMC("Template Max exceeded for:{0}\0"),footprint_crn);
  return;
 }
 tmstrcpy(fp[xf].day, day);
 tmstrcpy(fp[xf].begin, begin_time);
 tmstrcpy(fp[xf].end, end_time);
 tmstrcpy(fp[xf].schd, schd_code);
 xf++;
}

/* **************************************************************** */
/*   Compare footprint to template.                                 */ 
/* **************************************************************** */
static void process_ssrmeet_last(void)
{
/* xt max count for template */
/* xf max count for alternate crn footprint */
  int y;
  int z;
  int q;

/* look for a mismatch */
  for(y=0;y < xf; y++)
  {
    q = 0;
    for(z=0;z < xt;z++)
    {
      if(tmmemcmp (&fp[y],&tp[z],sizeof(toe))==0)
      {
        used_flag[z]=1;
        q=1;
      }
    }
    if (q==0)
      return;
  }

/* look for extra days */ 
  for(z=0;z < xt; z++)
    if(used_flag[z]=0)
      return;

/* found a match!! */
  use_alternate_crn = TRUE;
  tmstrcpy(alternate_crn,footprint_crn);
}

/* **************************************************************** */
/*   Copy closed section footprint to template.                     */
/* **************************************************************** */
static void create_template(void)
{ 
  xt=xf;
  tmmemcpy(tp,fp,sizeof(toe)*FP_COUNT);
}

/* **************************************************************** */
/*   Check for roll                                                 */
/*     Checks if student is eligible to enroll.                     */
/*     If so, calls the roll routine.                               */
/* **************************************************************** */
static void check_roll (void)
{
  class_eligible=check_deceased();
  if(class_eligible)
    class_eligible=check_hold();
  if(class_eligible)
    class_eligible=check_status_stdt();
  if(class_eligible)
    class_eligible=check_status_enrl();
  if(class_eligible)
    class_eligible=check_preq();
  if(class_eligible)
    class_eligible=check_duplicate();
/* leem - COS - 8-APR-2010
      Cmmented out pending mod to use correct CALB 8.2 repeat checking logic
  if(class_eligible)
    class_eligible=check_repeat();
*/
  if(class_eligible)
    class_eligible=check_time_conflict();
  if(class_eligible)
    class_eligible=check_max_units();
}

/* ****************************************************** */
/*   Process roll                                         */
/* ****************************************************** */
static void process_roll (void)
{
/*  Insert row into billing collector table SFRBTCH */  
  EXEC SQL
    INSERT INTO sfrbtch
      (sfrbtch_term_code,
       sfrbtch_pidm,
       sfrbtch_activity_date)
      VALUES(:ask_term,
             :stdt_pidm,
             SYSDATE);
  if(SQL_FAILED && !SQL_DUP_ROW) 
      POSTORA;
      
  if (use_alternate_crn)
  {
   tmstrcpy(action_code,_TMC("A"));
   
/* Increase enrollment numbers for alternate CRN.  */
   EXEC SQL
     SELECT rowid 
       INTO :alt_ssbsect_rowid 
       FROM ssbsect
      WHERE ssbsect_term_code = :ask_term
        AND ssbsect_crn = :alternate_crn
     FOR UPDATE OF ssbsect_enrl;
   POSTORA;
   
   EXEC SQL 
    UPDATE ssbsect
       SET ssbsect_reg_oneup = ssbsect_reg_oneup + 1,
           ssbsect_enrl = ssbsect_enrl + 1,
           ssbsect_seats_avail = ssbsect_seats_avail - 1,
           ssbsect_tot_credit_hrs = ssbsect_tot_credit_hrs + :credit_hours
     WHERE rowid = :alt_ssbsect_rowid;
   POSTORA;   
   tmprintf(&tmBundle, _TMC("Credit Hours: {0,number,0.00}   {1}\n"), credit_hours, alternate_crn);
   
   if (tmstrcmp(census_enrl_date,compare_date) >= 0)
   {
     EXEC SQL 
       UPDATE ssbsect
          SET ssbsect_census_enrl = ssbsect_census_enrl + 1
       WHERE rowid = :alt_ssbsect_rowid;
     POSTORA; 
   }
     
/* Decrease waitlist numbers for closed CRN.  */    
   EXEC SQL 
     UPDATE ssbsect
        SET ssbsect_wait_count = ssbsect_wait_count - 1,
            ssbsect_wait_avail = ssbsect_wait_avail + 1
     WHERE rowid = :ssbsect_rowid;
   POSTORA;  
   
/* Insert a registration row for alternate CRN */
   EXEC SQL
     INSERT INTO sfrstcr(
     sfrstcr_term_code,
     sfrstcr_pidm,
     sfrstcr_crn,
     sfrstcr_class_sort_key,
     sfrstcr_reg_seq,
     sfrstcr_ptrm_code,
     sfrstcr_rsts_code,
     sfrstcr_rsts_date,
     sfrstcr_error_flag,
     sfrstcr_message,
     sfrstcr_bill_hr,
     sfrstcr_waiv_hr,
     sfrstcr_credit_hr,
     sfrstcr_bill_hr_hold,
     sfrstcr_credit_hr_hold,
     sfrstcr_gmod_code,
     sfrstcr_grde_code,
     sfrstcr_grde_code_mid,
     sfrstcr_grde_date,
     sfrstcr_dupl_over,
     sfrstcr_link_over,
     sfrstcr_corq_over,
     sfrstcr_preq_over,
     sfrstcr_time_over,
     sfrstcr_capc_over,
     sfrstcr_levl_over,
     sfrstcr_coll_over,
     sfrstcr_majr_over,
     sfrstcr_clas_over,
     sfrstcr_appr_over,
     sfrstcr_appr_received_ind,
     sfrstcr_add_date,
     sfrstcr_activity_date,
     sfrstcr_levl_code,
     sfrstcr_camp_code,
     sfrstcr_reserved_key,
     sfrstcr_attend_hr,
     sfrstcr_rept_over,
     sfrstcr_rpth_over,
     sfrstcr_test_over,
     sfrstcr_camp_over,
     sfrstcr_user,
     sfrstcr_degc_over,
     sfrstcr_prog_over,
     sfrstcr_last_attend,
     sfrstcr_gcmt_code)
     SELECT sfrstcr_term_code,
            sfrstcr_pidm,
            :alternate_crn,
            NULL,
            fw_max_regs(:ask_term,:alternate_crn),
            sfrstcr_ptrm_code,
            'RE',
            SYSDATE,
            NULL,
            sfrstcr_message,
            :credit_hours,
            :credit_hours,
            :credit_hours,
            :credit_hours,
            :credit_hours,
            sfrstcr_gmod_code,
            NULL,
            NULL,
            NULL,
            sfrstcr_dupl_over,
            sfrstcr_link_over,
            sfrstcr_corq_over,
            sfrstcr_preq_over,
            sfrstcr_time_over,
            sfrstcr_capc_over,
            sfrstcr_levl_over,
            sfrstcr_coll_over,
            sfrstcr_majr_over,
            sfrstcr_clas_over,
            sfrstcr_appr_over,
            sfrstcr_appr_received_ind,
            SYSDATE,
            SYSDATE,
            sfrstcr_levl_code,
            sfrstcr_camp_code,
            sfrstcr_reserved_key,
            sfrstcr_attend_hr,
            sfrstcr_rept_over,
            sfrstcr_rpth_over,
            sfrstcr_test_over,
            sfrstcr_camp_over,
            'SWPWAIT',
            sfrstcr_degc_over,
            sfrstcr_prog_over,
            sfrstcr_last_attend,
            sfrstcr_gcmt_code
         FROM sfrstcr
        WHERE sfrstcr_pidm = :stdt_pidm
          AND sfrstcr_crn = :crn
          AND sfrstcr_term_code  =  :ask_term;
   POSTORA;      

/* Fix error flag if the section has an override */
   EXEC SQL
     UPDATE sfrstcr
        SET sfrstcr_error_flag = 'O'
      WHERE sfrstcr_pidm = :stdt_pidm
        AND sfrstcr_crn = :alternate_crn
        AND sfrstcr_term_code  =  :ask_term
        AND (sfrstcr_preq_over = 'Y'
          OR sfrstcr_rept_over = 'Y'
          OR sfrstcr_rpth_over = 'Y'
          OR sfrstcr_corq_over = 'Y');
   POSTORA;      

/* Delete registration row of closed CRN  */
   EXEC SQL
      DELETE from sfrstcr
       WHERE sfrstcr_rsts_code = 'WL'
         AND sfrstcr_crn = :crn
         AND sfrstcr_term_code = :ask_term
         AND sfrstcr_pidm = :stdt_pidm;
   POSTORA;      
  }
  else  /* open seat available in waitlisted crn */
  {
   tmstrcpy(action_code,_TMC("R"));
                  
/* COS - Added sfrstcr_rmsg_cde june 2010 - leem */                  
   EXEC SQL
    UPDATE sfrstcr
       SET sfrstcr_rsts_code = 'RE',
           sfrstcr_rsts_date = SYSDATE,
           sfrstcr_activity_date = SYSDATE,
           sfrstcr_credit_hr = :credit_hours,
           sfrstcr_bill_hr = :credit_hours,
     	    sfrstcr_waiv_hr = :credit_hours,
           sfrstcr_bill_hr_hold = :credit_hours,
           sfrstcr_credit_hr_hold = :credit_hours,
           sfrstcr_error_flag = NULL,
           sfrstcr_user = 'SWPWAIT',
           sfrstcr_rmsg_cde = null
     WHERE sfrstcr_crn = :crn
       and   sfrstcr_term_code = :ask_term
       and   sfrstcr_pidm = :stdt_pidm;
    POSTORA;


/* Fix error flag if the section has an override */
   EXEC SQL
     UPDATE sfrstcr
        SET sfrstcr_error_flag = 'O'
      WHERE sfrstcr_pidm = :stdt_pidm
        AND sfrstcr_crn = :crn
        AND sfrstcr_term_code  =  :ask_term
        AND (sfrstcr_preq_over = 'Y'
          OR sfrstcr_rept_over = 'Y'
          OR sfrstcr_rpth_over = 'Y'
          OR sfrstcr_corq_over = 'Y');
   POSTORA;      

/* Fix the enrollment numbers.  */

   EXEC SQL 
    UPDATE ssbsect
       SET ssbsect_enrl = ssbsect_enrl + 1,
           ssbsect_seats_avail = ssbsect_seats_avail - 1,
           ssbsect_tot_credit_hrs = ssbsect_tot_credit_hrs + :credit_hours,
           ssbsect_wait_count = ssbsect_wait_count - 1,
           ssbsect_wait_avail = ssbsect_wait_avail + 1
     WHERE rowid = :ssbsect_rowid;
    POSTORA;   
   tmprintf(&tmBundle, _TMC("Credit Hours: {0,number,0.00}   {1}\n"), credit_hours, crn);

    if (tmstrcmp(census_enrl_date,compare_date) >= 0)
    {
     EXEC SQL 
     UPDATE ssbsect
        SET ssbsect_census_enrl = ssbsect_census_enrl + 1
      WHERE rowid = :ssbsect_rowid;
     POSTORA; 
    }

/* update cross list enrollment counts if crosslist exists */
    if(*xlst_group) 
    {
     EXEC SQL
       UPDATE ssbxlst
          SET ssbxlst_enrl = ssbxlst_enrl + 1,
              ssbxlst_seats_avail = ssbxlst_seats_avail - 1
        WHERE rowid = :ssbxlst_rowid;
     POSTORA;
    }
  }
                                        
/* Fix the enrollment numbers in SWBWLST if an extra seat is used  */ 
   if (use_xtra_seats)
    {
      EXEC SQL 
        UPDATE swbwlst
        SET swbwlst_xtra_seats_remain = swbwlst_xtra_seats_remain - 1,
            swbwlst_xtra_seats_taken = swbwlst_xtra_seats_taken + 1
        WHERE rowid = :swbwlst_rowid;
      POSTORA;
    }
   
/* insert row into the waitlist roll log */ 
   if (use_alternate_crn)
   {
    EXEC SQL  
     INSERT INTO swrwllg
      (swrwllg_term_code,
       swrwllg_pidm,
       swrwllg_camp,
       swrwllg_crn,
       swrwllg_action_ind,
       swrwllg_reason_ind,
       swrwllg_reason_desc,
       swrwllg_user,
       swrwllg_activity_date)
       VALUES(:ask_term,
             :stdt_pidm,
             :campus_code,
             :alternate_crn,
             'R',
             'A',
             'Alternate Section',
             'SWPWAIT',
             SYSDATE);
      POSTORA; 
   }
   else
   {    
    EXEC SQL  
      INSERT INTO swrwllg
      (swrwllg_term_code,
       swrwllg_pidm,
       swrwllg_camp,
       swrwllg_crn,
       swrwllg_action_ind,
       swrwllg_reason_ind,
       swrwllg_reason_desc,
       swrwllg_user,
       swrwllg_activity_date)
      VALUES(:ask_term,
             :stdt_pidm,
             :campus_code,
             :crn,
             'R',
             'O',
             'Open Seat Available',
             'SWPWAIT',
             SYSDATE);
   POSTORA;                           
   }    

   oracle_commit();

/* Send email to student */ 
   selemail();

   if (*stdt_email) 
     send_email();
}

/* ****************************************************** */
/*   Remove the student from the waitlist.                */
/* ****************************************************** */
static void process_drop (void)
{
  tmstrcpy(action_code,_TMC("D"));
    
/* Drop student from waitlist */    
   EXEC SQL
    delete from sfrstcr
     WHERE sfrstcr_rsts_code = 'WL'
       AND sfrstcr_crn = :crn
       and sfrstcr_term_code = :ask_term
       and sfrstcr_pidm = :stdt_pidm;
   POSTORA;
                                        
/* Fix the enrollment numbers.  */
                              
   EXEC SQL 
     SELECT rowid 
       INTO :ssbsect_rowid
       FROM ssbsect
      WHERE ssbsect_term_code = :ask_term
        AND ssbsect_crn = :crn
      FOR UPDATE OF ssbsect_wait_count, ssbsect_wait_avail;
   POSTORA;
   
   EXEC SQL 
     UPDATE ssbsect
        SET ssbsect_wait_count = ssbsect_wait_count - 1,
            ssbsect_wait_avail = ssbsect_wait_avail + 1
      WHERE rowid = :ssbsect_rowid;
   POSTORA;
   
/* insert row into the waitlist roll log */ 
   EXEC SQL  
    INSERT INTO swrwllg
      (swrwllg_term_code,
       swrwllg_pidm,
       swrwllg_camp,
       swrwllg_crn,
       swrwllg_action_ind,
       swrwllg_reason_ind,
       swrwllg_reason_desc,
       swrwllg_user,
       swrwllg_activity_date)
      VALUES(:ask_term,
             :stdt_pidm,
             :campus_code,
             :crn,
             'D',
             :reason_code,
             :reason_code_desc,
             'SWPWAIT',
             SYSDATE);
   POSTORA; 

   oracle_commit();

/* Send email to student */ 
      selemail(); 
      if (*stdt_email)
         send_email();
}

/* ************************************** */
/*   If student is deceased               */
/*     return FALSE indicating student is */
/*     not eligible to register.          */
/* ************************************** */
static int check_deceased (void)
{
  tmstrcpy(deceased_flag,_TMC("N"));

  EXEC SQL 
     SELECT NVL (spbpers_dead_ind, 'N')
       INTO :deceased_flag
       FROM spbpers
      WHERE spbpers_pidm = :stdt_pidm;
  POSTORA;

  if(tmstrcmp(deceased_flag,_TMC("Y")) == 0)
   {
    tmstrcpy(reason_code, _TMC("X"));
    tmstrcpy(reason_code_desc, _TMC("Deceased"));
    tmstrcpy(reason_desc, reason_X);
    return(FALSE);
   }
  else
    return(TRUE);
}
                                                                     
/* ************************************** */
/*   Check student status.                */
/*   Return FALSE if student status is    */
/*     not eligible to register.          */
/* ************************************** */
static int check_status_stdt (void)
{
  tmstrcpy(stdt_status_flag,_TMC("N"));

  EXEC SQL 
     SELECT 'Y'
       INTO :stdt_status_flag
       FROM sgbstdn, stvstst
      WHERE sgbstdn_term_code_eff = (
            SELECT  MAX(X.sgbstdn_term_code_eff)
              FROM  sgbstdn X
             WHERE  X.sgbstdn_term_code_eff <= :ask_term
               AND  X.sgbstdn_pidm = :stdt_pidm)
     AND sgbstdn_pidm = :stdt_pidm
     AND stvstst_reg_ind <> 'Y'
     AND stvstst_code = sgbstdn_stst_code;
  POSTORA;

  if(tmstrcmp(stdt_status_flag,_TMC("Y")) == 0)
   {
    tmstrcpy(reason_code, _TMC("S"));
    tmstrcpy(reason_code_desc, _TMC("Student Status"));
    tmstrcpy(reason_desc, reason_S);
    return(FALSE);
   }
  else
    return(TRUE);
}
                                                                     
/* ************************************** */
/*   Check student enrollment status.     */
/*   Create an SFBETRM row if none exists */
/*        for the term.                   */
/*   Return FALSE if student status is    */
/*     not eligible to register.          */
/* ************************************** */
static int check_status_enrl (void)
{
  EXEC SQL 
     SELECT sfbetrm_ests_code
       INTO :ests_code
       FROM sfbetrm
      WHERE sfbetrm_term_code = :ask_term
        AND sfbetrm_pidm = :stdt_pidm;
  POSTORA;

  if (NO_ROWS_FOUND)
  {
     tmprintf(&tmBundle, _TMC("SFBETRM row not found.\n"));
     EXEC SQL 
        SELECT NVL (MIN (sfrmhrs_max_hrs), 99.99)
          INTO :max_hrs
          FROM sfrmhrs
         WHERE sfrmhrs_levl_code = 'C' 
           AND sfrmhrs_term_code = :ask_term;
     POSTORA;

     EXEC SQL
        INSERT INTO sfbetrm
          (sfbetrm_term_code,
           sfbetrm_pidm,
           sfbetrm_ests_code,
           sfbetrm_ests_date,
           sfbetrm_mhrs_over,
           sfbetrm_ar_ind,
           sfbetrm_add_date,
           sfbetrm_activity_date,
           sfbetrm_user)
        VALUES(:ask_term,
               :stdt_pidm,
                'EL',
                SYSDATE,
               :max_hrs,
                'Y',
                SYSDATE,
                SYSDATE,
                'SWPWAIT');
     POSTORA;
     return(TRUE);
  }
  else
  {
     if(tmstrcmp(ests_code,_TMC("EL")) != 0)
     {
      tmstrcpy(reason_code, _TMC("E"));
      tmstrcpy(reason_code_desc, _TMC("Registration Status"));
      tmstrcpy(reason_desc, reason_E);
      return(FALSE);
     }
     else
      return(TRUE);
  }
}

/* ************************************** */
/*   If student has a registration hold   */
/*     return FALSE indicating student is */
/*     not eligible to register.          */
/* ************************************** */
static int check_hold (void)
{
  tmstrcpy(hold_flag,_TMC("N"));

  EXEC SQL 
/*     SELECT DISTINCT 'Y'   */
     SELECT 'Holds - '||max(stvhldd_code)
       INTO :hold_flag
       FROM stvhldd
      WHERE stvhldd_reg_hold_ind = 'Y'
        AND stvhldd_code IN (SELECT sprhold_hldd_code
                               FROM sprhold
                              WHERE (
                                         TRUNC (SYSDATE) >=
                                         TRUNC (sprhold_from_date)
                                     AND TRUNC (SYSDATE) <
                                         TRUNC (sprhold_to_date)
                                    )
                                    AND sprhold_pidm = :stdt_pidm);
  POSTORA;

/*  if(tmstrcmp(hold_flag,_TMC("Y")) == 0) */
  if(tmstrcmp(hold_flag,_TMC("Holds - ")) != 0)
   {
    tmstrcpy(reason_code, _TMC("H"));
/*    tmstrcpy(reason_code_desc, _TMC("Holds"));   */
    tmstrcpy(reason_code_desc, hold_flag);
    tmstrcpy(reason_desc, reason_H);
    return(FALSE);
   }
  else
    return(TRUE);
}

/* ************************************** */
/*   Check prerequisites                  */
/*   If counselor override, return TRUE.  */
/*   If prequisites have not been met     */
/*     return FALSE indicating student is */
/*     not eligible to register.          */
/* ************************************** */
static int check_preq (void)
{
  EXEC SQL  
     SELECT 'Y'
       INTO :eligible_flag
       FROM sfrstcr
      WHERE sfrstcr_pidm = :stdt_pidm
        AND sfrstcr_crn = :crn
        AND sfrstcr_term_code  =  :ask_term
        AND (sfrstcr_preq_over = 'Y'
             OR sfrstcr_corq_over = 'Y');
  POSTORA;

  if (ROWS_FOUND)
    return(TRUE);

  EXEC SQL EXECUTE
   BEGIN
    swkcprq.pw_check_preq(TO_NUMBER(:stdt_pidm),
                          :ask_term,
                          :crn,
                          :eligible_flag);
   END;
  END-EXEC;

  if(tmstrcmp(eligible_flag,_TMC("N")) == 0)
   {
    tmstrcpy(reason_code, _TMC("P"));
    tmstrcpy(reason_code_desc, _TMC("Prerequisite"));
    tmstrcpy(reason_desc, reason_P);
    return(FALSE);
   }
  else
    return(TRUE);
}

/* ************************************** */
/*   Check start date of the section      */
/*                                        */
/*     return FALSE if section has        */
/*     begun                              */
/* ************************************** */
static int check_start_date (void)
{
  EXEC SQL
     SELECT 'Y'
       INTO :eligible_flag
       FROM ssbsect
      WHERE ssbsect_crn = :crn
        AND ssbsect_term_code  =  :ask_term
        AND baninst1.cos_courses.f_get_first_day_of_class(:crn,:ask_term,ssbsect_ptrm_start_date) > sysdate;
/*ryanwh:  commented out the following code for */
/*         a function that would return the courses */
/*         actual start date */
/*        AND ssbsect_ptrm_start_date > sysdate;*/

  POSTORA;

  if (ROWS_FOUND)
    return(TRUE);
  else
    return(FALSE);

}

/* ************************************** */
/*   Check repeats.                       */
/*     If course has been taken previously*/
/*     return FALSE indicating student is */
/*     not eligible to register.          */
/* ************************************** */
static int check_repeat (void)
{
  EXEC SQL  
     SELECT 'Y'
       INTO :eligible_flag
       FROM sfrsrpo
      WHERE sfrsrpo_term_code = :ask_term
        AND sfrsrpo_pidm = :stdt_pidm
        AND sfrsrpo_rovr_code = 'A&RSTAFF'
        AND sfrsrpo_subj_code = :subj_code
        AND sfrsrpo_crse_numb = :crse_numb
        AND (sfrsrpo_crn IS NULL
         OR  sfrsrpo_crn = :crn);
  POSTORA;

  if (ROWS_FOUND)
    return(TRUE);
      
  EXEC SQL  
     SELECT 'Y'
       INTO :eligible_flag
       FROM sfrstcr
      WHERE sfrstcr_pidm = :stdt_pidm
        AND sfrstcr_crn = :crn
        AND sfrstcr_term_code  =  :ask_term
        AND (sfrstcr_rept_over = 'Y'
             OR sfrstcr_rpth_over = 'Y');
  POSTORA;

  if (ROWS_FOUND)
    return(TRUE);

  EXEC SQL EXECUTE
   BEGIN
    shkrpts.p_count_repeat_units(:subj_code,
                          :crse_numb,
                          '',
                          :credit_hours,
                          'N',
                          '',
                          '',
                          '',
                          TO_NUMBER(:stdt_pidm),
                          :ask_term,
                          :repeat_units,
                          :repeat_count,
                          :repeat_units_limit,
                          :repeat_count_limit,
                          :repeat_flag,
                          :message_out);
   END;
  END-EXEC;

  if(tmstrcmp(repeat_flag,_TMC("N")) == 0)
    return(TRUE);
  else
   {
    tmstrcpy(reason_code, _TMC("R"));
    tmstrcpy(reason_code_desc, _TMC("Repeat"));
    tmstrcpy(reason_desc, reason_R);
    return(FALSE);
   }
}

/* **************************************** */
/*   Check time conflict.                   */
/*     If time conflict exists return FALSE */
/*     indicating student is not eligible   */
/*     to register.                         */
/* **************************************** */
static int check_time_conflict (void)
{
  EXEC SQL 
    SELECT fw_time_check_batch(TO_NUMBER(:stdt_pidm),
                          :ask_term,
                          :crn)
    INTO :time_conflict_flag
    FROM DUAL;            

  if(tmstrcmp(time_conflict_flag,_TMC("Y")) == 0)
   {
    tmstrcpy(reason_code, _TMC("T"));
    tmstrcpy(reason_code_desc, _TMC("Time Conflict"));
    tmstrcpy(reason_desc, reason_T);
    return(FALSE);
   }
  else
   return(TRUE);
}

/* ************************************** */
/*   Check for duplicate.                 */
/*     If student is currently registered */
/*     in a course with a matching Subj   */
/*     and Course Number, return FALSE    */
/*     indicating student is              */
/*     not eligible to register.          */
/* ************************************** */
static int check_duplicate (void)
{
  EXEC SQL 
    SELECT fw_duplicate_check_batch(TO_NUMBER(:stdt_pidm),
                                    :ask_term,
                                    :crn)
    INTO :duplicate_flag
    FROM DUAL;            

  if(tmstrcmp(duplicate_flag,_TMC("Y")) == 0)
   {
    tmstrcpy(reason_code, _TMC("D"));
    tmstrcpy(reason_code_desc, _TMC("Duplicate Course"));
    tmstrcpy(reason_desc, reason_D);
    return(FALSE);
   }
  else
    return(TRUE);
}

/* ************************************** */
/*   Check if maximum units exceeded.     */
/*   If max units have been exceeded then */
/*     return FALSE indicating student is */
/*     not eligible to register.          */
/* ************************************** */
static int check_max_units (void)
{
  tmstrcpy(max_units_flag, _TMC("N"));
  total_credit_hours = 0;
  EXEC SQL
    SELECT NVL(SUM(sfrstcr_credit_hr), 0)
      INTO :total_credit_hours
      FROM sfrstcr
     WHERE sfrstcr_rsts_code in ('RE', 'RW')
       AND sfrstcr_pidm = :stdt_pidm
       AND sfrstcr_term_code = :ask_term;
  POSTORA;
        
   EXEC SQL
     SELECT 'Y'
       INTO :max_units_flag
       FROM sfrstcr, sfbetrm
      WHERE sfrstcr_crn = :crn
        AND sfrstcr_pidm = :stdt_pidm
        AND sfrstcr_term_code = :ask_term
        AND sfbetrm_mhrs_over < :total_credit_hours + :credit_hours
        AND sfbetrm_pidm = :stdt_pidm
        AND sfbetrm_term_code = :ask_term;
   POSTORA;
                         
  if(tmstrcmp(max_units_flag,_TMC("Y")) == 0)
   {
    tmstrcpy(reason_code, _TMC("U"));
    tmstrcpy(reason_code_desc, _TMC("Max Units Exceeded"));
    tmstrcpy(reason_desc, reason_U);
    return(FALSE);
   }
  else
    return(TRUE);
}

/* ***************************************************** */
/*        Send Student email notificaton of Action Taken */
/* ***************************************************** */
static int send_email (void)
{
   /* Build Email Command String                         */
   /* mailx -s $subject -r $mailfrom $mailto < $emailbody */
    if (tmstrcmp(action_code,_TMC("D"))==0)
      tmstrcpy(email_string,_TMC("mailx -s COS_Waitlist_Drop_Notification "));
    else
      if (tmstrcmp(action_code,_TMC("R"))==0)
         tmstrcpy(email_string,_TMC("mailx -s COS_Registered_Notification ")); 
      else
         if (tmstrcmp(action_code,_TMC("A"))==0)
            tmstrcpy(email_string,_TMC("mailx -s COS_Registered_Notification "));
    
    build_email_body();

/*    if (strcmp(ask_email_flag,"N")==0)
      strcat(email_string,"");
    else
      strcat(email_string, campus_email);

    strcat(email_string, " ");
*/

    if (tmstrcmp(ask_email_flag,_TMC("N"))==0)
      tmstrcat(email_string,test_email);
    else
      tmstrcat(email_string,stdt_email);
      
    tmstrcat(email_string, _TMC(" < /var/tmp/ebody.txt"));
    tmsystem (email_string);

    return(TRUE);
}

/* ************************************ */
/*  Get email address                   */
/* ************************************ */
static int selemail(void)
{
  EXEC SQL
    SELECT NVL(Cos_f_Get_Inst_Email(:stdt_pidm),' ')
    INTO :stdt_email
    FROM dual;
  POSTORA;

  if (tmstrcmp(stdt_email, _TMC(" "))==0)
    tmstrcpy(stdt_email, _TMC(""));

  /* fix_null(stdt_email,Ind_01); */
    
  if (*stdt_email)
    return TRUE;
  else
    return FALSE;
}

/* **************************************** */
/*  build the file to be sent as email body */
/* **************************************** */
static void build_email_body(void)
{
  /* get student full name */
  EXEC SQL
    SELECT SUBSTR(RTRIM(spriden_first_name)||' '||RTRIM(spriden_last_name),1,60)
    INTO :stdt_name
    FROM spriden
   WHERE spriden_change_ind is null
     AND spriden_pidm = :stdt_pidm;
  POSTORA;

  if((eb = tmfopen(&tmBundle, _TMC("/var/tmp/ebody.txt"), _TMC("w")))==NULL)
  {
    tmprintf(&tmBundle, _TMC("Unable to open ebody.txt\n"));
    bad_open = FALSE;
    return;
  }

  tmfprintf(&tmBundle, eb, _TMC("College of the Sequoias Banner System\n\n"));  
  tmfprintf(&tmBundle, eb, _TMC("This message is to notify {0} of a schedule change.\n"),stdt_name);  
  if (tmstrcmp(action_code,_TMC("R"))== 0)
  { 
     tmfprintf(&tmBundle, eb, _TMC("The course for which you were waitlisted CRN:{0} {1} {2} has been officially added to your schedule.\n"),crn,subj_code,crse_numb);
     tmfprintf(&tmBundle, eb, _TMC("Please verify your new schedule on the web and remit payment within 14 days.\n"));
  }
 
  if (tmstrcmp(action_code,_TMC("A"))== 0)
  { 
     tmfprintf(&tmBundle, eb, _TMC("You have been registered for CRN:{0} {1} {2}.  This new section meets on the same days and times as the section in which you were previously waitlisted.\n"),
         alternate_crn,subj_code,crse_numb);            
/*     fprintf(eb, "This course meets in building/room %s %s \n"),bldg_code, room_code;  */
     tmfprintf(&tmBundle, eb, _TMC("Please verify the new meeting location by viewing your schedule on the web and remit payment within 14 days.\n"));
  }

  if (tmstrcmp(action_code, _TMC("D"))==0)
  { 
     tmfprintf(&tmBundle, eb, _TMC("You have been dropped from the wait list for course CRN:{0} {1} {2} because {3}\n"),crn,subj_code,crse_numb,reason_desc);
     tmfprintf(&tmBundle, eb, _TMC(" If you have any questions please contact the admissions and records office at  {0}.\n"),campus_contact);
  }
  tmfprintf(&tmBundle, eb, _TMC("Click this link to access Banner Web. https://banweb.cos.edu"));

  tmfclose(eb);
}

/* ****************************************** */
/*  Initialize footprint used flag.           */
/* ****************************************** */
static int initialize_used_flags (void)
{
   int x;

   for (x=0; x<FP_COUNT; x++)
     {
       used_flag[x]=0;
     }
   return(TRUE);
}

/* ****************************************** */
/*  Initialize footprint.                     */
/* ****************************************** */
static int initialize_footprint (void)
{
   int x;

   for (x=0; x<FP_COUNT; x++)
     {
       fp[x].day[0]='\0';
       fp[x].begin[0]='\0';
       fp[x].end[0]='\0'; 
       fp[x].schd[0]='\0';                                       
     }
   return(TRUE);
}

/* ************************************ */
/*  Format current date for compare.    */
/* ************************************ */
static void format_compare_date (void)
{
  EXEC SQL
    SELECT TO_CHAR(SYSDATE,'YYYYMMDD')
      INTO :compare_date
        FROM DUAL;
  POSTORA;
}




            
/*TMCI18N BEGIN GLOBAL STRING INITIALIZATION*/
#ifndef ORA_PROC
void tmInitGlobS_swpwait(void){
	TMCHARRAY_GLOB_INIT(test_email);
	TMCHARRAY_GLOB_INIT(COS_mailfrom);
	TMCHARRAY_GLOB_INIT(COS_contact);
	TMCHARRAY_GLOB_INIT(reason_X);
	TMCHARRAY_GLOB_INIT(reason_H);
	TMCHARRAY_GLOB_INIT(reason_P);
	TMCHARRAY_GLOB_INIT(reason_S);
	TMCHARRAY_GLOB_INIT(reason_E);
	TMCHARRAY_GLOB_INIT(reason_D);
	TMCHARRAY_GLOB_INIT(reason_R);
	TMCHARRAY_GLOB_INIT(reason_U);
	TMCHARRAY_GLOB_INIT(reason_T);

	#ifdef _DEBUG
	puts("*** Initialisation tmInitGlobS_swpwait OK ***\n");
	#endif
}
#endif /* not defined ORA_PROC*/
/*TMCI18N END GLOBAL STRING INITIALIZATION*/

